---
title: Rust 学习2
date: 2025-04-05 15:56:20
tags: "Rust"
cover: https://mks-1306588458.cos.ap-nanjing.myqcloud.com/rust.png
---
# Rust 基础知识
## Rust 变量
Rust 变量分为两种：不可变变量和可变变量。
### 不可变变量
不可变变量的值不能被修改，一旦被赋值就不能再修改。
```rust
let x = 1;
x = 2; // 编译错误
```
### 可变变量
可变变量的值可以被修改。
```rust
let mut x = 1;
x = 2; // 编译通过
```
### 常量
常量是在编译时就确定值的变量，不能被修改。
```rust
const PI: f64 = 3.1415926;
PI = 3.14; // 编译错误
```
### shadowing
shadowing是指在同一作用域内重新声明一个变量，这个变量的名称和类型必须和之前的变量相同。
```rust
let x = 1;
let x = 2; // 编译通过
```
### 变量类型
Rust 变量类型分为两种：基本类型和复合类型。
### 基本类型
基本类型是 Rust 内置的类型，包括整数、浮点数、布尔值、字符等。
```rust
let x: i32 = 1;
let y: f64 = 1.0;
let z: bool = true;
let w: char = 'a';
```
### 复合类型
复合类型是由多个基本类型组成的类型，包括元组、数组、结构体、枚举等。
```rust
let x: (i32, f64) = (1, 1.0);
let y: [i32; 3] = [1, 2, 3];
struct Point {
    x: i32,
    y: i32,
}
let z = Point { x: 1, y: 2 };
enum Color {
    Red,
    Green,
    Blue,
}
let w = Color::Red;
```
### 其余类型例如Vec, HashMap等可以在标准库中找到
```rust
let x = vec![1, 2, 3];
let y = HashMap::new();
```
### 空值
Rust 中的空值是 `()`，表示没有值。
```rust
let x = (); // 空值
let y: () = (); // 空值
let z: () = (1, 2); // 编译错误
let w = (1, 2); // 编译通过，类型推导为元组
```
### 类型推导
Rust 可以根据变量的值自动推导类型，不需要显式指定类型。
```rust
let x = 1; // x: i32
let y = 1.0; // y: f64
let z = true; // z: bool
let w = 'a'; // w: char
```
### 类型别名
类型别名是指给类型起一个别名，方便使用。
```rust
type Int = i32;
let x: Int = 1;
```
### 类型转换
Rust 可以进行类型转换，
```rust
let x: i32 = 1;
let y: f64 = x as f64; // 显式转换
let z = x + y; // 编译错误
let w = x as f64 + y; // 编译通过
let a = x + y as i32; // 编译通过
let c = x + y as f64; // 编译通过
```
### Rust类型安全规则
禁止隐式转换，除非显式转换。
表达式的类型必须一致。

### 序列
Rust提供了一个非常简洁的方式来创建序列，称为`range`。
range是一个迭代器，它可以生成一个序列。其为`左闭右开`区间。
例如 `1..5`，生成从 1 到 4 的连续数字序列,不包含5。`1..=5`，生成从 1 到 5 的连续数字序列,包含5。
```rust
for i in 1..=5 {
    println!("{}",i);
}
```
最终程序会输出：
```
1
2
3
4
5
```
### 有理数和复数
Rust提供了一个标准库`num`，其中包含了有理数和复数的类型。
```rust
use num::rational::Ratio;
let x = Ratio::new(1, 2);
let y = Ratio::new(1, 3);
let z = x + y;
println!("{}", z);
```
最终程序会输出：
```
5/6
```
```rust
use num::complex::Complex;
let x = Complex::new(1, 2);
let y = Complex::new(3, 4);
let z = x + y;
println!("{}", z);
```
最终程序会输出：
```
4+6i
```

---
## 字符、布尔和单元类型
### 字符类型 char
字符类型 char 表示一个 Unicode 字符，用单引号括起来。
```rust
let x = 'a';
let y = '中';
let z = '😀';
```
Rust中的字符类型是Unicode字符，因此可以表示任何语言的字符。
Unicode是一种国际标准，用于表示世界上几乎所有的字符。
Unicode的编码范围非常广泛，值的范围从U+0000\~U+D7FF和U+E000~U+10FFFF。由于Unicode都是4个字节，因此Rust中的字符类型是char，占用`4个字节`。
```rust
let x = 'a';
println!("{}", size_of_val(&x)); // 输出4
```
### 布尔类型 bool
布尔类型 bool 表示真或假，用 true 和 false 表示。
```rust
let x = true;
let y: bool = false;
if y {
    println!("这是段毫无意义的代码");
}
```
布尔类型 bool 占用`1个字节`。
```rust
let x = true;
println!("{}", size_of_val(&x)); // 输出1
```
### 单元类型 ()
单元类型就是 () ，对，你没看错，就是 () ，唯一的值也是 () ，
只能说，再不起眼的东西，都有其用途，在目前为止的学习过程中，大家已经看到过很多次 fn main() 函数的使用吧？那么这个函数返回什么呢？

没错， main 函数就返回这个单元类型 ()，你不能说 main 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：发散函数( diverge function )，顾名思义，无法收敛的函数。

例如常见的 println!() 的返回值也是单元类型 ()。

再比如，你可以用 () 作为 map 的值，表示我们不关注具体的值，只关注 key。 这种用法和 Go 语言的 `struct{}` 类似，可以作为一个值用来占位，但是完全`不占用`任何内存。

---

### 语句和表达式
语句和表达式是 Rust 中的两种基本概念。
语句是执行某种操作的代码块，例如变量声明、函数调用、条件语句等。语句通常不返回值。
表达式是计算并返回值的代码块，例如变量、常量、函数调用、运算符等。表达式可以作为语句的一部分，也可以作为表达式的一部分。
例如：
```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式或者是return x + y;
}
```
语句会执行一些操作但是不会返回一个值，而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。
注意表达式的最后一行不需要分号，如果加了分号必须加return关键字。

### 语句
```rust
let a = 8;
let b: Vec<f64> = Vec::new();
let (a, c) = ("hi", false);
```
以上都是语句，它们完成了一个具体的操作，但是没有返回值。
由于let是语句，因此不能将let语句赋值给变量，例如：
```rust
let x = let y = 1; // 编译错误
```
### 表达式
表达式会进行求值，然后返回一个值，例如：`5+6`，在求值后，返回`11`，因此它就是一个表达式。
表达式可以作为语句的一部分，例如：`let x = 6; // 表达式`,`6`就是一个表达式，它在求值后返回`6`，因此它可以作为语句的一部分。
调用一个函数是表达式，例如：`println!("Hello, world!");`，它在求值后返回`()`，因此它可以作为语句的一部分。调用宏也是表达式，例如：`println!("Hello, world!");`，它在求值后返回`()`，因此它可以作为语句的一部分。用花括号包裹最终返回一个值的语句块也是表达式，例如：`{let x = 1; x}`，它在求值后返回`1`，因此它可以作为语句的一部分。

最后，表达式如果不返回任何值，那么它的类型就是`()`，这也是一个表达式。
```rust
fn main() {
    assert_eq!(ret_unit_type(), ())
}

fn ret_unit_type() {
    let x = 1;
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    // 类似三元运算符，在Rust里我们可以这样写
    let y = if x % 2 == 1 {
        "odd"
    } else {
        "even"
    };
    // 或者写成一行
    let z = if x % 2 == 1 { "odd" } else { "even" };
}
```


--- 
## 函数
Rust 的函数我们在之前已经见过不少，跟其他语言几乎没有什么区别。因此本章的学习之路将轻松和愉快，骚年们，请珍惜这种愉快，下一章你将体验到不一样的 Rust。

在函数界，有一个函数只闻其名不闻其声，可以止小孩啼！在程序界只有 `hello,world!` 可以与之媲美，它就是 `add` 函数：
```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}
```
该函数如此简单，但是又是如此的五脏俱全，声明函数的关键字 fn，函数名 add()，参数 i 和 j，参数类型和返回值类型都是 i32，总之一切那么的普通，但是又那么的自信
### 函数要点
- 函数名和变量名使用蛇形命名法(snake case)，例如 fn add_two() -> {}
- 函数的位置可以随意，但是必须在 main 函数之前声明
- 每个函数参数必须指定类型
- 函数的返回值类型可以省略，但是必须有 return 语句
- 函数的参数可以是任何类型，包括基本类型、复合类型、引用类型、指针类型等
### 函数返回
函数的返回值类型可以省略，但是必须有 return 语句，例如：
```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}
```
如果函数的返回值类型省略，那么 Rust 会根据函数体的最后一行代码的类型来推断返回值类型，例如：
```rust
fn add(x: i32, y: i32) {
    x + y
}
```
再来看一段代码，同时使用 return 和表达式作为返回值：
```rust
fn plus_or_minus(x:i32) -> i32 {
    if x > 5 {
        return x - 5
    }

    x + 5
}

fn main() {
    let x = plus_or_minus(5);

    println!("The value of x is: {}", x);
}
```
`plus_or_minus` 函数根据传入 `x` 的大小来决定是做加法还是减法，若 `x > 5` 则通过 `return` 提前返回 `x - 5` 的值,否则返回 `x + 5` 的值。

### Rust中的特殊返回值
Rust 中的特殊返回值是 `()`，表示没有值。
- 函数没有返回值，那么返回一个 ()
- 通过`;`结尾的语句，返回一个 ()